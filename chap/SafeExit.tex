\section{The A-Tor Protocol}
\label{sec:safeexit}

This section describes the A-Tor protocol in details,
  including the steps to apply for anonymous certificates,
               to perform anonymous communications,
               and to link the anonymous communication to the user.

These notations are used in this paper:
\begin{itemize}
\item $ID^{OR}_i$, $PK_i$, $SK_i$: the identity, the public key and the private key of $OR_i$.
\item $PK_u$, $SK_u$: an ephemeral key pair generated by the user.
%\item $ID^s_i$, $K_i$: the session identity and the session key between the user and $OR_i$.
\item $ID^c_i$: the connection identity between the user and $OR_i$ in the Tor circuit.
%\item $Hash(e)$: the digest of a message $e$ by a hash function.
\item $Enc_{K}[e]$, $Dec_{K}[e]$: encrypt and decrypt message $e$ by key $K$.
\item $Sign_{K}[e]$: sign message $e$ by key $K$.
\end{itemize}


\subsection{Anonymous Certificate}
\label{subsec:certificate}

As shown in Figure \ref{pic:protocol},
  the A-Tor user constructs the anon-cert Tor circuit consisting of $m$ ORs, denoted as $OR_i$ and $1 \leq i \leq m$.
$OR_1$ is the registration node, and $OR_m$ is the certification node.
After the circuit is constructed,
  the user shares a secure connection with $OR_i$, which is identified as $ID_i^c$.
The detailed steps to construct a Tor circuit is described in \cite{dingledine2004tor}.

Then,
 the user generates an ephemeral key pair ($PK_u, SK_u$),
   constructs an anonymous  certificate request $ACertReq_{m+1} = Sign_{SK_u}[PK_u, T_s, T_e]$,
   and computes
%$ACertReq_{i} = ID^{OR}_i || Enc_{K_i}[ID^c_i, ACertReq_{i+1}] || H(K_i) || Enc_{PK_i}[K_i]$
$ACertReq_{i} = ID^{OR}_i || Enc_{PK_i}[ID^c_i, ACertReq_{i+1}]$
iteratively,
 where ($T_s$, $T_e$) is the period of validity and $1 \leq i \leq m$.
The certificate requests are also encrypted like the layers of an onion.
Next, the user sends
$ACertReq_{1} || cred$
 to $OR_1$, where $cred$ is a credential of his/her identity.

Upon receiving $ACertReq_{1} || cred$, $OR_1$ verifies $cred$ and decrypts it to obtain $ACertReq_{2}$. Then,
 it sends $Sign_{SK_1}[ACertReq_{2}]$ to $OR_2$.
Upon receiving $Sign_{SK_{i-1}}[ACertReq_{i}]$,
   $OR_i$ verifies the signature and decrypts it to obtain $ACertReq_{i+1}$,
   until $OR_m$ obtains $ACertReq_{m+1}$.
At the same time,
 $OR_i$ stores $Sign_{SK_{i-1}}[ACertReq_{i}]$ as a verifiable proof.

$OR_m$ signs the  certificate $ACert_{u,m} = Sign_{SK_m}(PK_u, ID^{OR}_m, T_s, T_e)$.
This anonymous  certificate is relayed back to the user through the Tor circuit.

%According to the exit policy specified by the SafeExit node,  the user applies the ACert of different types.
%In this section, we describe the generation for ACert for strong audit and weak audit respectively.

%讲证书的组成、作用、生成和撤销。
%is a binding of a public key($PubKey_s$) and the Tor streams begun from a user,
% while the corresponding private key ($PriKey_s$) is owned by the user.
%In detail, the ACert is in form of [$seq$, $type$, $ID_{AOR_s}$, $PubKey_s$, $time_s$, $time_e$, $sig$],
% where the $seq$ uniquely identifies the certificate in the ones  issued by the AOR whose identifier is $ID_{AOR_s}$,
% $PubKey_s$ is the public key for Tor streams while the corresponding private key ($PriKey_s$) is owned by the user,
% $time_s$ and $time_e$ are chosen by the user to define the period of certificate validity,
%  and the $sig$ is the signature of the other parts of the ACert which is generated using the private key of the $AOR_s$.
%Before signing the ACert, the $AOR_s$ only has to ensure that the current time is less than $time_e$.



%%%Unlike the Tor tunnel adopts TLS to secure the communication between the user and the ORs,
%%% the messages in the SafeExit tunnel are encrypted using the receiver's public key, as the amount of the communication in the SafeExit tunnel is small,
%%%that is, one round communication to generate the ACert.


\begin{figure}[bt]
 \centering
  % Requires \usepackage{graphicx}
  \includegraphics[width=9.5cm]{pic/A-Tor-Proto.pdf}\\
  \caption{The A-Tor Protocol.}\label{pic:protocol}
\end{figure}



\subsection{Anonymous Communication}
The steps to perform anonymous communication in A-Tor is almost the same as those in Tor,
  except that the relayed network packets are signed by the A-Tor user and verified by the exit node.

As shown in Figure \ref{pic:protocol}, an A-Tor user constructs a Tor circuit consisting of $n$ ORs, denoted as $OR_j$ and $1 \leq j \leq n$.
$OR_n$ is the exit node,
  and no OR is in the anon-cert Tor circuit and the anon-comm Tor circuit at the same time.
After the Tor circuit is constructed
and before any packet to the destination is sent,
   the A-Tor user sends $ACert_{u,m}$ to the exit node through the circuit.
The exit node verifies that the certificate is signed by another OR, and in its period of validity,
  and replies with an acknowledgement.
Otherwise, it rejects to forward any packet.

Then,
 the user begins to send packets through the Tor circuit.
It signs every packet using $SK_s$ and transmits the signed packet to the exit node.
The exit node forwards a packet (without the signature) to the destination server,
 only if it is sent along with a valid signature.
The Tor circuit shall be closed before the certificate expires.
The certificate and signatures are stored by the exit node as verifiable proofs in the future.

%On receiving the ACert, the SafeExit node checks whether the $type$ is consistent with its exit policy,   verifies the correctness of its signature and closes the Tor stream if any check fails.
%For performance, the ACert in SafeExit node can be used in multiple Tor streams and cannot be revoked.
%The user has to protect the $PriKey_s$, ensuring it never leaked beofre the ACert expires.
%The user should specify the  $time_s$ and $time_s$ properly to balance the trade-off between the performance and the risk of key leakage.
 %Moreover, it can apply different ACerts for Tor streams that need different anonymity levels,
%  and provide shorter validity period for these with higher anonymity levels.

The A-Tor user may use one anonymous certificate for multiple Tor circuits of anonymous communication,
    depending on his/her own security concern.
Because the application of anonymous certificates is expensive,
  we recommend an anonymous certificate shall be used in multiple Tor circuits.

\subsection{Accountable Anonymity}
\label{subsec:audit}
If the traffic forwarded by the exit node is detected to be illegal or malicious,
  an auditor who is authorized by law enforcement agencies,
    performs the following steps  to reveal the user's identity.

%When the traffic between the SafeExit node and the destination satisfies the audit condition, %~\footnote{The detail audit condition is out of the scope, and may be specified by the law.},
% for example, the traffic is related with terrorist activities or the network attacks,

%需要注意的是：SafeExit node和destination之间是明文通信，他们之间的消息的可靠性（如m和m_{dest})使用其他方法保证，不在本文考虑范围

The auditor brings the illegal or malicious packets to the exit node,
  and the exit node will present the corresponding certificate $ACert_{u,m}$ and signatures.
After verifying the certificate and signatures,
 the auditor requires $OR_m$ to present $Sign_{SK_{m-1}}[ACertReq_{m}]$.
Otherwise, if the certificate or any signature is invalid,
   the exit node is liable for these illegal or malicious packets.

%$OR_m$ decrypts $K_m$ from $ACertReq_{m}$,
%  the auditor verifies that $H(K_m)$ is in $ACertReq_{m}$
%  and decrypts $ACertReq_{m+1}$ by $K_m$.
$OR_m$ decrypts $ACertReq_{m+1}$ from $ACertReq_{m}$,
 and the auditor checks whether the anonymous-certificate request message $ACertReq_{m+1}$ matches the certificate $ACert_{u,m}$ or not;
    if they match,
    the auditor verifies the signature by $OR_{m-1}$ and
     then requires $OR_{m-1}$ to present $Sign_{SK_{m-2}}[ACertReq_{m-1}]$.

The auditor traces the ORs one by one in the anon-cert Tor circuit
  and finally the registration node presents $ACertReq_{1} || cred$.
The user's identity is revealed in $cred$ verifiably.
During the above steps,
  if any OR cannot present a valid certificate request message,
   the OR is liable for these illegal or malicious packets.


%%%1. The auditor collects the message ($m_{dest}$) from the destination and extracts the receiving time ($time_{dest}$) from the destination's log.

%%%2. The auditor gets the ACert and the signature of $m_{dest}$ from the SafeExit node.
%%%  After obtaining the $ID_{AOR_n}$ from the ACert, it verifies the signature in the ACert using $PK_n$,
%%%        checks whether the ACert is in the validity period  at  $time_{dest}$,
%%%       and verifies the signature of $m_{dest}$ using $PubKey_s$ in the ACert.
%%%   If any check fails, the auditor stops the process.

%%%3. The auditor uses the ACert to obtain $ID_{AOR_{n-1}}$, $nonce_{n}$ and $[nonce_{AOR_{n-1}},$ $type,$ $ACertReq_{n}$$]_{SK_{n-1}}$ at $AOR_n$.
%%%After obtaining $K_n$ by requiring the $AOR_n$ to decrypt $ACertReq_{n}$,
%%%the auditor checks the correctness of the provided $K_n$ using $H(K_n)$ in the $ACertReq_{n}$,
%%% and the consistency of the decrypted $nonce_n$, $time_s$, $time_e$, $PubKey_s$ with the ones in the ACert.
%%% Then, it verifies the signature in  $[nonce_{AOR_{n-1}},$ $type,$ $ACertReq_{n}$$]_{SK_{n-1}}$ with $PK_{n-1}$.
%%%Only when all the checks succeed, the auditor continues the process.

%%%4. For $AOR_{j}$ ($1 < j < n$), the auditor uses $nonce_{AOR_j}$ to get $nonce_j$, $ID_{AOR_{j-1}}$ and $[nonce_{AOR_{j-1}}$, $type,$ $ACertReq_{j}$ $]_{SK_{j-1}}$.
%%%After obtaining the decrypted $K_j$ from the $AOR_{j}$, the auditor checks it with $H(K_n)$ in the $ACertReq_{j}$,
%%% and the consistency of decrypted $ACertReq_{j+1}$ with the one obtained at $AOR_{j+1}$.
%%%Moreover, the auditor checks the signature in $[nonce_{AOR_{j-1}}$, $type,$ $ACertReq_{j}$ $]_{SK_{j-1}}$ using $PK_{j-1}$.
%%%    Only when all the checks succeed, the auditor turns to the next AOR.

%%%5. The audit at the $AOR_1$ is different for the weak  and strong audit:
%%%\begin{itemize}
%%%  \item In weak audit, the auditor uses $nonce_{AOR_1}$ to retrieve $nonce_1$, $[ACertReq_1]$ and the user's IP address.
   %%%Then it uses the $K_1$ decrypted by the $AOR_1$ to decrypt the first part of $[ACertReq_1]$ and gets $[ID_{AOR_{2}},$ $nonce_1$, $ACertReq_{2}]$.
%%%   If the digest of the decrypted $K_1$ is inconsistent with the $H(K_1)$ in $[ACertReq_1]$, or the $ACertReq_{2}$ is different from the one provided by $AOR_2$, the audit halts at $AOR_1$, otherwise, the audit succeeds.
%%%  \item In strong aduit, the auditor uses $nonce_{AOR_1}$ to retrieve $[ACertReq_1]_{SK_u}$ and  $nonce_1$ at $AOR_1$.
%%%   Except the checks performed in the weak audit, the verifies the signature in $[ACertReq_1]_{SK_u}$ using the user's public key.
%%%   If all the checks succeed, the audit succeeds and the user is the initiator of the Tor traffic;
%%%     otherwise, the audit halts at $AOR_1$.
%%%\end{itemize}


%%%Each node (i.e., AORs and the SafeExit nodes) has the responsibility to record the log correctly.
%%%From the above process, we find that the audit succeeds once all the logs are correct.
%%%However, if the audit halts at some node, we require that node to afford the liability for the Tor traffic,
%%% as it may indeed collude with the malicious nodes to prevent the audit.

%%%Moreover, the communication between the SafeExit node and the destination is out of Tor, the correctness of $m_{dest}$ and $time_{dest}$ are ensured using other mechanisms.

